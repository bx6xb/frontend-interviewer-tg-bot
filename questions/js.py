js_questions = {
  1: {
    "question": "Какие типы данных существуют в JavaScript?",
    "answer": "В JavaScript существуют 7 примитивных типов данных: string, number, bigint, boolean, undefined, symbol и null. Также есть один объектный тип данных — объект (object), который включает в себя массивы, функции, даты и другие структуры данных."
  },
  2: {
    "question": "В чём разница между null и undefined?",
    "answer": "undefined — это значение, которое присваивается переменной, если ей не было назначено значение. null — это явное присваивание переменной пустого значения. То есть undefined — это отсутствие значения, а null — это намеренное отсутствие значения."
  },
  3: {
    "question": "Как работает приведение типов в JavaScript?",
    "answer": "В JavaScript происходит неявное приведение типов, когда операнды различных типов используются в одной операции. Например, при сложении строки и числа строка будет преобразована в число. Приведение типов может быть неявным (например, при операциях с разными типами) или явным с помощью функций, таких как String(), Number() и Boolean()."
  },
  4: {
    "question": "Что такое NaN и как проверить, является ли значение NaN?",
    "answer": "NaN (Not a Number) — это специальное значение, которое обозначает ошибку при попытке выполнить числовую операцию, которая не может быть вычислена. Для проверки, является ли значение NaN, используется функция Number.isNaN(), так как просто сравнивать с NaN через == или === не работает (NaN не равно самому себе)."
  },
  5: {
    "question": "Как работает typeof? Какие есть нюансы?",
    "answer": "typeof — это оператор, который возвращает строку, указывающую тип операнда. Однако, есть некоторые нюансы: typeof null возвращает 'object', что является ошибкой в языке, и typeof для массивов или функций также возвращает 'object'. Для проверки массива лучше использовать Array.isArray(), а для функций проверку следует делать через typeof function."
  },
  6: {
    "question": "Как сравниваются значения в == и ===?",
    "answer": "Оператор == выполняет сравнение с приведением типов, т.е. может преобразовать значения к одному типу перед сравнением. Оператор === сравнивает значения без приведения типов, т.е. учитываются как значение, так и тип данных. Например, '5' == 5 вернёт true, но '5' === 5 вернёт false."
  },
  7: {
    "question": "Чем let, const и var отличаются друг от друга?",
    "answer": "let и const имеют блочную область видимости, тогда как var имеет функциональную область видимости. const используется для объявления переменных, значения которых не могут быть изменены после их присваивания. let же позволяет изменять значение переменной. var следует избегать в современном коде из-за проблем с областью видимости."
  },
  8: {
    "question": "Что такое шаблонные строки (template literals) и зачем они нужны?",
    "answer": "Шаблонные строки — это строки, заключенные в обратные кавычки (` `), которые позволяют вставлять выражения прямо в строку с помощью ${}. Это удобно для создания строк с динамическими значениями, а также поддерживает многострочные строки."
  },
  9: {
    "question": "Как создать объект в JavaScript? Какие есть способы?",
    "answer": "Объект можно создать с помощью литерала объекта: const obj = {}; или с помощью конструктора Object: const obj = new Object(); Также можно использовать функцию-конструктор или класс для создания объектов."
  },
  10: {
    "question": "Как клонировать объект без мутации оригинала?",
    "answer": "Для клонирования объекта без мутации можно использовать методы, такие как Object.assign({}, obj) или операторы распространения (spread operator) {...obj}. Для глубокого клонирования, например, с вложенными объектами, можно использовать JSON.parse(JSON.stringify(obj)), хотя это имеет ограничения."
  },
  11: {
    "question": "Что такое hoisting?",
    "answer": "Hoisting — это механизм в JavaScript, при котором объявления переменных и функций поднимаются в начало своей области видимости. Это означает, что переменные и функции могут быть использованы до их фактического объявления в коде. Однако только объявления, а не инициализации, поднимаются."
  },
  12: {
    "question": "В чём разница между function declaration и function expression?",
    "answer": "Function declaration — это объявление функции с использованием ключевого слова function, которое имеет функциональную область видимости и поднимается в начало. Function expression — это функция, присвоенная переменной, которая не поднимается, а её значение доступно только после присваивания."
  },
  13: {
    "question": "Как работает стрелочная функция и чем она отличается от обычной?",
    "answer": "Стрелочные функции имеют сокращённый синтаксис (например, const sum = (a, b) => a + b). Главное отличие — это то, что стрелочные функции не имеют своего контекста (this), и используют внешний контекст, что важно для обработки событий или работы с методами объектов."
  },
  14: {
    "question": "Как работает замыкание (closure)?",
    "answer": "Замыкание — это функция, которая сохраняет доступ к переменным своей внешней области видимости, даже после того как эта область видимости завершила выполнение. Это позволяет создавать функции с приватными переменными и задерживать выполнение функций."
  },
  15: {
    "question": "Как создать функцию с произвольным количеством аргументов?",
    "answer": "Для создания функции с произвольным количеством аргументов можно использовать оператор rest (...args), который собирает все переданные аргументы в массив. Например, const sum = (...args) => args.reduce((a, b) => a + b, 0);."
  },
  16: {
    "question": "Что такое рекурсия и как она работает?",
    "answer": "Рекурсия — это процесс, при котором функция вызывает саму себя для решения подзадач. Важно правильно задать условие выхода, чтобы избежать бесконечного рекурсивного вызова и ошибки переполнения стека."
  },
  17: {
    "question": "В чём разница между call, apply и bind?",
    "answer": "call и apply позволяют вызвать функцию с явным указанием контекста (this) и аргументов. Разница заключается в том, что call принимает аргументы через запятую, а apply — через массив. bind возвращает новую функцию с установленным контекстом и аргументами, но не вызывает её сразу."
  },
  18: {
    "question": "Что такое контекст выполнения (this)?",
    "answer": "Контекст выполнения (this) — это объект, к которому привязана функция в момент её вызова. Значение this зависит от того, как была вызвана функция: это может быть глобальный объект, объект, вызвавший метод, или объект, явившийся контекстом стрелочной функции."
  },
  19: {
    "question": "Как работает setTimeout и setInterval?",
    "answer": "setTimeout и setInterval — это функции для работы с таймерами. setTimeout вызывает функцию один раз через определённый промежуток времени, а setInterval вызывает её регулярно с заданным интервалом. Для остановки таймера используется clearTimeout или clearInterval."
  },
  20: {
    "question": "В чём разница между map, forEach, filter и reduce?",
    "answer": "map создаёт новый массив, применяя функцию ко всем элементам исходного массива. forEach выполняет функцию для каждого элемента, но не возвращает новый массив. filter создаёт новый массив, содержащий только те элементы, которые прошли проверку функции. reduce выполняет агрегирование элементов массива, возвращая одно значение (например, сумму или среднее)."
  },
  21: {
    "question": "Чем отличается синхронный код от асинхронного?",
    "answer": "Синхронный код выполняется последовательно, где одна операция начинается только после завершения предыдущей. Асинхронный код позволяет запускать операции, не блокируя основной поток выполнения, и обрабатывать их результаты позже, что делает приложение более отзывчивым."
  },
  22: {
    "question": "Как работает Promise и какие у него состояния?",
    "answer": "Promise — это объект, представляющий асинхронную операцию, которая может завершиться успешно (resolve), завершиться с ошибкой (reject) или остаться в ожидании (pending). Основные состояния: pending (ожидание), fulfilled (выполнен), rejected (отклонён)."
  },
  23: {
    "question": "Как использовать async/await?",
    "answer": "async/await — это синтаксический сахар для работы с асинхронным кодом. Функция, помеченная как async, всегда возвращает Promise. Внутри такой функции можно использовать await для ожидания завершения Promise до того, как продолжить выполнение кода."
  },
  24: {
    "question": "Что делает Promise.all и чем он отличается от Promise.race?",
    "answer": "Promise.all принимает массив промисов и ожидает завершения всех промисов. Если один из них отклоняется, весь Promise.all отклоняется. Promise.race также принимает массив промисов, но возвращает результат первого завершившегося промиса, независимо от того, был он успешным или отклонённым."
  },
  25: {
    "question": "Как обработать ошибки в async/await?",
    "answer": "Ошибки в async/await обрабатываются с помощью конструкции try/catch. Код, который может вызвать ошибку, оборачивается в блок try, и если ошибка возникает, она перехватывается в блоке catch."
  },
  26: {
    "question": "В чём разница между setTimeout(fn, 0) и requestAnimationFrame?",
    "answer": "setTimeout(fn, 0) откладывает выполнение функции на минимальное время, которое зависит от таймеров браузера, но всё равно может быть задержано из-за других операций. requestAnimationFrame вызывает функцию до следующего перерисовывания экрана, обеспечивая более точную синхронизацию с кадрами и минимальную задержку."
  },
  27: {
    "question": "Как работает Event Loop?",
    "answer": "Event Loop — это механизм, который позволяет JavaScript выполнять асинхронные операции. Он состоит из двух очередей: macro-task и micro-task. После выполнения синхронного кода, Event Loop обрабатывает задачи из micro-task очереди, а затем из macro-task очереди."
  },
  28: {
    "question": "В чём разница между microtask queue и macrotask queue?",
    "answer": "Microtask queue (очередь микрозадач) используется для обработки микрозадач, таких как Promises и обработчики событий, зарегистрированные с использованием queueMicrotask(). Macrotask queue (очередь макрозадач) используется для обработки более крупных задач, таких как setTimeout, setInterval, и событий ввода."
  },
  29: {
    "question": "Что произойдёт, если вызвать fetch внутри setTimeout?",
    "answer": "Если вызвать fetch внутри setTimeout, то запрос будет отправлен асинхронно после того, как основной код выполнится и время, заданное в setTimeout, истечет. Это не блокирует выполнение других операций, так как fetch — асинхронный запрос."
  },
  30: {
    "question": "Как отменить Promise?",
    "answer": "Promise сам по себе не имеет встроенного метода отмены. Однако можно использовать подход с созданием и управлением состоянием через дополнительные конструкции, такие как AbortController, который позволяет отменить асинхронные операции, такие как fetch, через аборт-сигнал."
  },
  31: {
    "question": "Как получить элемент со страницы в JavaScript?",
    "answer": "Для получения элемента из DOM используется методы, такие как getElementById, querySelector, querySelectorAll, getElementsByClassName, getElementsByTagName. Каждый из этих методов позволяет найти элементы на странице по различным критериям (ID, класс, тег и т.д.)."
  },
  32: {
    "question": "Чем querySelector отличается от getElementById?",
    "answer": "querySelector позволяет выбрать первый элемент, который соответствует CSS-селектору, в то время как getElementById возвращает элемент по уникальному идентификатору (ID). querySelector более универсален, так как поддерживает все CSS-селекторы."
  },
  33: {
    "question": "Как создать и добавить элемент в DOM?",
    "answer": "Чтобы создать элемент, используется document.createElement(). После создания элемента его можно добавить в DOM с помощью методов, таких как appendChild, insertBefore, или с помощью свойства innerHTML."
  },
  34: {
    "question": "Как удалить элемент из DOM?",
    "answer": "Для удаления элемента из DOM используется метод removeChild, который удаляет указанный дочерний элемент, или метод remove, который удаляет сам элемент."
  },
  35: {
    "question": "Как работает делегирование событий?",
    "answer": "Делегирование событий — это подход, при котором обработчик события устанавливается на родительский элемент, и при возникновении события на дочернем элементе оно 'пузырится' до родителя, который его обрабатывает. Это позволяет избежать добавления обработчиков на каждый дочерний элемент."
  },
  36: {
    "question": "Как остановить всплытие события?",
    "answer": "Для остановки всплытия события используется метод event.stopPropagation(). Этот метод предотвращает дальнейшее распространение события по дереву DOM, что позволяет избежать его обработки родительскими элементами."
  },
  37: {
    "question": "В чём разница между target и currentTarget?",
    "answer": "target — это элемент, на котором было инициировано событие, а currentTarget — это элемент, к которому прикреплен обработчик события. В делегировании событий currentTarget всегда будет указывать на родительский элемент, в то время как target — на элемент, на котором произошло событие."
  },
  38: {
    "question": "Как изменить стили элемента через JavaScript?",
    "answer": "Для изменения стилей элемента используется свойство element.style, которое позволяет напрямую изменить инлайн-стили. Например, element.style.backgroundColor = 'red';."
  },
  39: {
    "question": "Что такое dataset и зачем оно нужно?",
    "answer": "dataset — это свойство элемента, которое позволяет работать с пользовательскими аттрибутами данных, начинающимися с 'data-'. Эти атрибуты можно использовать для хранения дополнительной информации о DOM-элементе, а затем легко получить их в JavaScript."
  },
  40: {
    "question": "Как сделать плавный скролл к элементу?",
    "answer": "Для плавного скролла к элементу можно использовать метод scrollIntoView() с параметром { behavior: 'smooth' }. Например: element.scrollIntoView({ behavior: 'smooth' });."
  },
  41: {
    "question": "Что такое прототипное наследование?",
    "answer": "Прототипное наследование — это механизм, позволяющий объектам наследовать свойства и методы от других объектов. Каждый объект в JavaScript имеет внутреннюю ссылку на свой прототип, который является объектом, от которого объект может унаследовать свойства и методы."
  },
  42: {
    "question": "Как работает Object.create?",
    "answer": "Object.create — это метод, который создаёт новый объект с указанным прототипом и опциональными свойствами. Это позволяет гибко управлять прототипным наследованием, создавая объект с нужным прототипом."
  },
  43: {
    "question": "В чём разница между __proto__ и prototype?",
    "answer": "__proto__ — это внутреннее свойство объекта, которое ссылается на его прототип, тогда как prototype — это свойство функции-конструктора, которое ссылается на объект, являющийся прототипом всех экземпляров, созданных с помощью этой функции."
  },
  44: {
    "question": "Как создать класс в JavaScript?",
    "answer": "Класс в JavaScript создаётся с помощью ключевого слова class. Например: class MyClass { constructor() {} }."
  },
  45: {
    "question": "Чем extends в классе отличается от Object.create?",
    "answer": "extends используется для создания классов, которые наследуют свойства и методы другого класса. Object.create создаёт новый объект с указанным прототипом. extends работает с классами, а Object.create — с объектами."
  },
  46: {
    "question": "Как работает super в классах?",
    "answer": "super используется для вызова методов или конструктора родительского класса. В конструкторе дочернего класса super() вызывает конструктор родительского класса, а в методах super.method() позволяет вызвать метод родителя."
  },
  47: {
    "question": "Что делает static в классе?",
    "answer": "static позволяет создать метод или свойство, которое доступно только на уровне класса, а не на уровне экземпляров. Такие методы и свойства можно вызвать через сам класс, а не через его экземпляры."
  },
  48: {
    "question": "Как сделать приватные свойства в классе?",
    "answer": "Приватные свойства в классе можно создать, используя символы (#) перед именем свойства, например: #privateProp. Также можно использовать WeakMap или методы с замыканиями для имитации приватных данных."
  },
  49: {
    "question": "Как переопределить метод родительского класса?",
    "answer": "Для переопределения метода родительского класса в дочернем классе нужно просто определить новый метод с таким же именем в дочернем классе. При необходимости можно вызвать родительский метод с помощью super."
  },
  50: {
    "question": "Как работает instanceof?",
    "answer": "instanceof проверяет, является ли объект экземпляром указанного конструктора или класса. Возвращает true, если объект принадлежит этому классу или его наследникам."
  },
  51: {
    "question": "Как скопировать массив без мутации оригинала?",
    "answer": "Для копирования массива без мутации оригинала можно использовать методы, такие как slice(), spread оператор [...array], или метод Array.from(). Эти методы создают новый массив, не изменяя исходный."
  },
  52: {
    "question": "В чём разница между push, pop, shift и unshift?",
    "answer": "push добавляет элемент в конец массива, pop удаляет элемент с конца массива, shift удаляет элемент с начала массива, а unshift добавляет элемент в начало массива."
  },
  53: {
    "question": "Как найти элемент в массиве?",
    "answer": "Для поиска элемента в массиве можно использовать методы find() для поиска первого подходящего элемента, indexOf() для получения индекса элемента, или includes() для проверки наличия элемента в массиве."
  },
  54: {
    "question": "Чем find отличается от filter?",
    "answer": "find возвращает первый элемент, который удовлетворяет условию, или undefined, если такой элемент не найден. filter возвращает новый массив, содержащий все элементы, которые удовлетворяют условию."
  },
  55: {
    "question": "Как отсортировать массив? Какие подводные камни у sort?",
    "answer": "Массив можно отсортировать с помощью метода sort(). Однако, по умолчанию, sort() сортирует элементы как строки, что может привести к неожиданным результатам для чисел. Чтобы отсортировать числа правильно, необходимо передать в sort() функцию сравнения."
  },
  56: {
    "question": "Как объединить два массива?",
    "answer": "Для объединения двух массивов можно использовать методы concat() или spread оператор [...array1, ...array2]."
  },
  57: {
    "question": "Как проверить, является ли объект массивом?",
    "answer": "Для проверки, является ли объект массивом, можно использовать метод Array.isArray()."
  },
  58: {
    "question": "Как преобразовать объект в массив?",
    "answer": "Для преобразования объекта в массив можно использовать Object.entries(), Object.keys() или Object.values(), в зависимости от того, какие данные нужно извлечь из объекта."
  },
  59: {
    "question": "Как удалить свойство из объекта?",
    "answer": "Для удаления свойства из объекта можно использовать оператор delete. Например: delete obj.property."
  },
  60: {
    "question": "Как проверить, содержит ли объект определённое свойство?",
    "answer": "Для проверки, содержит ли объект определённое свойство, можно использовать оператор in или метод hasOwnProperty(). Например: 'property' in obj или obj.hasOwnProperty('property')."
  },
  61: {
    "question": "Как работают import и export в ES-модулях?",
    "answer": "В ES-модулях ключевые слова import и export используются для импорта и экспорта функционала между файлами. import позволяет импортировать функции, объекты или переменные из других модулей, а export позволяет экспортировать функционал текущего модуля. Важно, что модули в ES6 работают асинхронно, и каждый файл считается отдельным модулем."
  },
  62: {
    "question": "Чем default export отличается от именованного экспорта?",
    "answer": "Default export позволяет экспортировать одну сущность (функцию, объект или класс) как основной экспорт модуля, который затем можно импортировать с любым именем. Именованный экспорт экспортирует несколько сущностей, и при импорте необходимо точно указать имена этих сущностей."
  },
  63: {
    "question": "Как динамически загрузить модуль?",
    "answer": "Для динамической загрузки модуля в ES6 используется функция import(). Она позволяет загружать модули по мере необходимости, возвращая Promise. Например: `import('./module.js').then(module => { console.log(module); })`."
  },
  64: {
    "question": "Что такое tree shaking?",
    "answer": "Tree shaking — это техника, используемая в сборщиках модулей (например, Webpack), которая удаляет неиспользуемый код из финального бандла. Это помогает уменьшить размер пакета, исключив код, который не используется в приложении."
  },
  65: {
    "question": "Как работает require в CommonJS?",
    "answer": "В CommonJS require используется для синхронного импорта модулей. Он позволяет загрузить и выполнить модуль, а затем вернуть экспортированные из него объекты или функции. Например: `const myModule = require('./myModule.js');`."
  },
  66: {
    "question": "В чём разница между CommonJS и ES-модулями?",
    "answer": "CommonJS использует синхронный импорт с функцией require и экспортирует модули через module.exports. ES-модули используют асинхронный импорт через import и экспорт через ключевые слова export. ES-модули являются стандартом ECMAScript, а CommonJS используется в Node.js."
  },
  67: {
    "question": "Как организовать код в больших проектах?",
    "answer": "В больших проектах код организуют через использование модулей и разделение функциональности на отдельные компоненты. Используют структурированные директории, именование файлов по конвенциям, а также применение подходов типа MVC или модульного паттерна."
  },
  68: {
    "question": "Как использовать barrel file для экспорта модулей?",
    "answer": "Barrel file — это файл, который объединяет все экспорты из других модулей в одном месте. Это позволяет упростить импорты в других частях приложения. Например, создать файл `index.js`, который будет экспортировать все модули: `export * from './moduleA'; export * from './moduleB';`."
  },
  69: {
    "question": "Как сделать модуль глобальным?",
    "answer": "Для того чтобы модуль стал глобальным, можно присвоить его функциональность глобальной переменной или использовать системы модулей, которые автоматически загружаются в глобальный контекст, например через CDN или с помощью глобальных переменных в браузере."
  },
  70: {
    "question": "Почему не стоит злоупотреблять глобальными переменными?",
    "answer": "Злоупотребление глобальными переменными может привести к конфликтам имен, утечкам памяти и трудно отлавливаемым ошибкам. Глобальные переменные доступны во всей программе, что увеличивает шанс их случайной перезаписи или изменения."
  },
  71: {
    "question": "Какие основные уязвимости существуют в JavaScript?",
    "answer": "Основные уязвимости включают XSS (межсайтовый скриптинг), CSRF (межсайтовые подделки запросов), инъекции SQL, утечки данных через консоль и уязвимости, связанные с неправильным использованием eval или функций обработки данных."
  },
  72: {
    "question": "Как работает XSS и как его предотвратить?",
    "answer": "XSS (межсайтовый скриптинг) позволяет злоумышленникам внедрять вредоносный JavaScript в страницы, которые посещают другие пользователи. Для предотвращения XSS важно использовать экранирование входных данных, фильтрацию и безопасное внедрение контента (например, через innerHTML или eval)."
  },
  73: {
    "question": "Что такое CSRF и как защититься от него?",
    "answer": "CSRF (межсайтовая подделка запросов) позволяет злоумышленнику отправить запрос от имени пользователя без его ведома. Защита от CSRF включает использование уникальных токенов (например, в заголовках) и проверку происхождения запросов с помощью таких механизмов, как SameSite cookies."
  },
  74: {
    "question": "В чём опасность eval?",
    "answer": "eval выполняет строку как код JavaScript, что может быть опасно, если строка содержит неподтвержденный пользовательский ввод. Это может привести к выполнению произвольного кода, открывая возможности для XSS-атак."
  },
  75: {
    "question": "Как защититься от утечки данных через console.log?",
    "answer": "Чтобы предотвратить утечку данных через console.log, следует избегать вывода конфиденциальной информации в консоль, особенно в продакшн-среде. Также можно использовать обертки вокруг console.log, чтобы исключить вывод определённых данных или его полностью в рабочем приложении."
  },
  76: {
    "question": "Как уменьшить потребление памяти в JavaScript?",
    "answer": "Для уменьшения потребления памяти в JavaScript нужно избегать утечек памяти, правильно управлять объёмом данных, освобождать ненужные объекты и использовать структуры данных, оптимизированные по памяти, такие как Set и Map."
  },
  77: {
    "question": "Что такое дебаунсинг (debouncing) и троттлинг (throttling)?",
    "answer": "Дебаунсинг — это техника, при которой функция вызывается только после того, как прекращаются быстрые последовательные вызовы, например, при вводе в поле поиска. Троттлинг ограничивает количество вызовов функции в определённый промежуток времени."
  },
  78: {
    "question": "В чём разница между localStorage, sessionStorage и cookies?",
    "answer": "localStorage сохраняет данные в браузере без срока действия, sessionStorage — на время текущей сессии, а cookies позволяют сохранять данные с возможностью указания срока жизни и передачи на сервер с каждым запросом."
  },
  79: {
    "question": "Как работает weakMap и weakSet?",
    "answer": "weakMap и weakSet — это коллекции, которые хранят объекты, но не предотвращают их сборку мусора. Это означает, что если объект больше не используется, он будет удалён из коллекции, что помогает избежать утечек памяти."
  },
  80: {
    "question": "Как избежать утечек памяти в JavaScript?",
    "answer": "Для предотвращения утечек памяти следует правильно управлять ссылками на объекты, удалять неиспользуемые объекты и следить за закрытыми замыканиями, которые могут удерживать ссылки на объекты, даже если они больше не нужны."
  },
  81: {
    "question": "Как работает fetch?",
    "answer": "Fetch — это API для работы с HTTP-запросами, позволяющее получать ресурсы из сети. Он возвращает Promise, который разрешается в объект Response, с которым можно работать для получения данных с помощью методов like .json(), .text(), .blob() и других."
  },
  82: {
    "question": "Как отправить POST-запрос с fetch?",
    "answer": "Чтобы отправить POST-запрос с fetch, нужно указать метод 'POST' в объекте настроек, а также передать необходимые данные в теле запроса. Пример: `fetch(url, { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(data) })`."
  },
  83: {
    "question": "Как обработать ошибку сети при fetch?",
    "answer": "Ошибки сети можно обрабатывать с помощью catch() на Promise. Для более точной обработки ошибок необходимо проверять response.ok, чтобы убедиться, что запрос был успешным. Пример: `fetch(url).then(response => { if (!response.ok) throw new Error('Network response was not ok'); return response.json(); }).catch(error => console.error('There was a problem with the fetch operation:', error));`."
  },
  84: {
    "question": "В чём разница между localStorage и indexedDB?",
    "answer": "localStorage — это простое хранилище для хранения данных в виде строк, которые могут быть синхронно записаны и прочитаны. Оно имеет ограничения по объёму данных и не поддерживает сложные запросы. indexedDB — это более мощная система хранилища данных, поддерживающая структурированные данные и сложные запросы, позволяет работать с большими объемами данных и предоставляет асинхронный API."
  },
  85: {
    "question": "Как получить координаты пользователя через JavaScript?",
    "answer": "Для получения координат пользователя используется метод getCurrentPosition API геолокации. Пример: `navigator.geolocation.getCurrentPosition(successCallback, errorCallback);`, где successCallback — это функция, которая получит объект с координатами, а errorCallback — функция обработки ошибок."
  },
  86: {
    "question": "Как работать с WebSocket?",
    "answer": "WebSocket позволяет создавать двустороннее соединение между клиентом и сервером. Для работы с ним используется объект WebSocket, например: `const socket = new WebSocket('ws://example.com');`. Подключение и обмен сообщениями выполняются через методы socket.onopen, socket.onmessage, socket.send и socket.close."
  },
  87: {
    "question": "Как определить, онлайн ли пользователь?",
    "answer": "Чтобы определить, онлайн ли пользователь, можно использовать событие 'online' и 'offline' на объекте window. Например: `window.addEventListener('online', () => { console.log('User is online'); }); window.addEventListener('offline', () => { console.log('User is offline'); });`."
  },
  88: {
    "question": "Как работает Notification API?",
    "answer": "Notification API позволяет веб-приложениям отправлять уведомления пользователю. Для работы с ним нужно сначала запросить разрешение через `Notification.requestPermission()`. Если разрешение получено, можно создать уведомление с помощью `new Notification('Text', options)`."
  },
  89: {
    "question": "Что такое Service Worker?",
    "answer": "Service Worker — это скрипт, который работает в фоновом режиме, независимо от веб-страницы, и позволяет делать такие вещи, как кэширование ресурсов, работа с уведомлениями и обработка запросов в фоновом режиме. Он помогает создавать прогрессивные веб-приложения (PWA)."
  },
  90: {
    "question": "Как работает WebRTC?",
    "answer": "WebRTC (Web Real-Time Communication) позволяет устанавливать прямые P2P-соединения для обмена аудио, видео и другими данными между браузерами без необходимости использования промежуточных серверов. Для этого используются API, такие как getUserMedia, RTCPeerConnection и RTCDataChannel."
  },
  91: {
    "question": "Как работает hash table?",
    "answer": "Hash table (хеш-таблица) использует хеш-функцию для преобразования ключа в индекс, по которому можно найти соответствующее значение. Это позволяет делать операции поиска, вставки и удаления за время O(1), если хеш-функция равномерно распределяет ключи."
  },
  92: {
    "question": "Чем стек отличается от очереди?",
    "answer": "Стек (LIFO — Last In, First Out) работает по принципу «последний пришёл — первый ушёл», то есть элементы добавляются и удаляются с одного конца. Очередь (FIFO — First In, First Out) работает по принципу «первый пришёл — первый ушёл», элементы добавляются в конец, а удаляются с начала."
  },
  93: {
    "question": "Как реализовать LRU Cache?",
    "answer": "LRU (Least Recently Used) Cache можно реализовать с использованием структуры данных, такой как двусвязный список и хеш-таблица. Хеш-таблица обеспечивает быстрый доступ к элементам, а двусвязный список позволяет эффективно перемещать элементы в начало при их использовании и удалять наименее используемые элементы в конце."
  },
  94: {
    "question": "Как найти пересечение двух массивов?",
    "answer": "Пересечение двух массивов можно найти, используя методы filter и includes. Например: `const intersection = arr1.filter(value => arr2.includes(value));`."
  },
  95: {
    "question": "Как отсортировать массив чисел без sort?",
    "answer": "Чтобы отсортировать массив чисел без метода sort, можно использовать алгоритмы сортировки, такие как пузырьковая сортировка или сортировка вставками. Например, пузырьковая сортировка: `for (let i = 0; i < arr.length; i++) { for (let j = 0; j < arr.length - i - 1; j++) { if (arr[j] > arr[j + 1]) { [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]]; } } }`."
  },
  96: {
    "question": "Как найти самую длинную подстроку без повторяющихся символов?",
    "answer": "Для поиска самой длинной подстроки без повторяющихся символов можно использовать метод с двумя указателями. Один указатель двигается по строке, а второй отслеживает текущую подстроку. Когда встречается повторный символ, сдвигаем левый указатель. Пример: `let maxLength = 0, start = 0; for (let end = 0; end < str.length; end++) { if (set.has(str[end])) { start = Math.max(start, set.get(str[end]) + 1); } set.set(str[end], end); maxLength = Math.max(maxLength, end - start + 1); }`."
  },
  97: {
    "question": "Как работает binary search?",
    "answer": "Binary search (бинарный поиск) используется для нахождения элемента в отсортированном массиве, сравнивая его с элементом в середине массива. Если элемент меньше, поиск продолжается в левой половине, если больше — в правой. Алгоритм работает за время O(log n)."
  },
  98: {
    "question": "Как работает merge sort?",
    "answer": "Merge sort — это алгоритм сортировки, который использует принцип «разделяй и властвуй». Массив делится на две части, каждая из которых сортируется рекурсивно, а затем части сливаются в один отсортированный массив. Его сложность — O(n log n)."
  },
  99: {
    "question": "Как проверить, является ли строка палиндромом?",
    "answer": "Чтобы проверить, является ли строка палиндромом, можно перевернуть строку и сравнить её с оригиналом. Например: `const isPalindrome = str === str.split('').reverse().join('');`."
  },
  100: {
    "question": "Как определить, содержит ли массив дубликаты?",
    "answer": "Чтобы проверить, содержит ли массив дубликаты, можно преобразовать его в Set (который не допускает повторяющихся значений) и сравнить его длину с длиной оригинального массива. Пример: `const hasDuplicates = new Set(arr).size !== arr.length;`."
  },
  "total": 100
}