react_questions = {
  1: {
    "question": "Что такое React и зачем он нужен?",
    "answer": "React — это библиотека JavaScript для создания пользовательских интерфейсов, особенно для одностраничных приложений. Он позволяет разрабатывать UI-компоненты, которые можно повторно использовать, а также эффективно обновлять интерфейс благодаря Virtual DOM."
  },
  2: {
    "question": "В чём разница между React и обычным JavaScript при работе с DOM?",
    "answer": "В обычном JavaScript манипуляции с DOM выполняются напрямую, что может быть неэффективно при изменении больших частей интерфейса. В React используется Virtual DOM, который сначала обновляет виртуальное представление UI, а затем синхронизирует изменения с реальным DOM, минимизируя перерасход ресурсов."
  },
  3: {
    "question": "Что такое Virtual DOM и как он работает?",
    "answer": "Virtual DOM — это абстракция реального DOM, представляющая собой копию UI, хранящуюся в памяти. Когда состояние приложения изменяется, React обновляет Virtual DOM, затем сравнивает его с предыдущей версией и минимизирует количество изменений в реальном DOM."
  },
  4: {
    "question": "Какие преимущества у React перед другими фреймворками?",
    "answer": "React имеет высокую производительность благодаря использованию Virtual DOM, обеспечивает удобное повторное использование компонентов, позволяет легко управлять состоянием с помощью библиотек, таких как Redux, и поддерживает серверный рендеринг для SEO."
  },
  5: {
    "question": "Какое расширение файлов используют для компонентов в React?",
    "answer": "Для компонентов в React обычно используют расширение файлов .jsx (для компонентов с JSX-разметкой) или .js (для обычных JavaScript-файлов без JSX). В случае с TypeScript — .tsx."
  },
  6: {
    "question": "Почему в React используют JSX?",
    "answer": "JSX позволяет писать компоненты, используя синтаксис, похожий на HTML, что упрощает создание UI. Это делает код более читаемым и удобным для разработчиков. JSX затем компилируется в обычный JavaScript, который браузер может выполнить."
  },
  7: {
    "question": "Можно ли писать React-код без JSX?",
    "answer": "Да, можно писать React-код без JSX, используя только методы, такие как React.createElement. Однако это сделает код более сложным и трудным для восприятия, так как JSX предоставляет более удобный синтаксис для создания элементов."
  },
  8: {
    "question": "Что делает метод React.createElement?",
    "answer": "Метод React.createElement используется для создания React-элементов. Он принимает тип элемента (например, 'div' или компонент), его пропсы и дочерние элементы, и возвращает объект, который React использует для рендеринга."
  },
  9: {
    "question": "Как работает рендеринг в React?",
    "answer": "Рендеринг в React происходит в несколько этапов: React создает Virtual DOM, затем сравнивает его с предыдущей версией с помощью алгоритма диффа. После этого он обновляет реальный DOM только там, где произошли изменения, что повышает производительность."
  },
  10: {
    "question": "Почему нельзя изменять state напрямую?",
    "answer": "Изменение state напрямую в React приводит к нежелательным побочным эффектам, так как React не будет знать о изменении и не выполнит повторный рендер компонента. Вместо этого следует использовать функцию setState, которая уведомляет React о необходимости обновления состояния и перерисовки компонента."
  },
  11: {
    "question": "Что такое компонент в React?",
    "answer": "Компонент в React — это самостоятельная часть пользовательского интерфейса, которая может быть использована в разных местах приложения. Компоненты могут быть функциональными или классовыми, и они принимают входные данные (пропсы) и возвращают UI-элементы."
  },
  12: {
    "question": "Чем функциональные компоненты отличаются от классовых?",
    "answer": "Функциональные компоненты — это функции, которые возвращают UI и могут использовать хуки для работы с состоянием и побочными эффектами. Классовые компоненты являются классами, которые наследуют от React.Component и имеют методы, такие как render(), setState(), и другие для управления состоянием."
  },
  13: {
    "question": "Как передавать пропсы в компонент?",
    "answer": "Пропсы передаются в компонент как атрибуты в JSX. Например, <Component name='John' />, где 'name' — это пропс. Внутри компонента его можно получить через объект props (например, props.name)."
  },
  14: {
    "question": "Что такое children в React?",
    "answer": "children — это специальный пропс в React, который позволяет передавать вложенные элементы в компонент. Это используется для создания более универсальных и переиспользуемых компонентов."
  },
  15: {
    "question": "Как можно задать значения по умолчанию для пропсов?",
    "answer": "Для задания значений по умолчанию для пропсов в функциональных компонентах можно использовать defaultProps. Например: MyComponent.defaultProps = { name: 'Unknown' }."
  },
  16: {
    "question": "Что такое 'контейнерные' и 'презентационные' компоненты?",
    "answer": "Контейнерные компоненты (или умные компоненты) управляют состоянием и логикой, тогда как презентационные компоненты (или глупые компоненты) отвечают только за отображение данных. Контейнеры часто передают пропсы в презентационные компоненты."
  },
  17: {
    "question": "Можно ли передавать функцию как проп?",
    "answer": "Да, в React можно передавать функцию как проп. Это часто используется для обработки событий или передачи логики между компонентами."
  },
  18: {
    "question": "Как можно предотвратить ненужные ререндеры компонента?",
    "answer": "Чтобы предотвратить ненужные ререндеры, можно использовать React.memo для функциональных компонентов и shouldComponentUpdate для классовых компонентов. Также можно использовать хуки, такие как useMemo и useCallback, чтобы мемоизировать значения и функции."
  },
  19: {
    "question": "Что такое 'контролируемые' и 'неконтролируемые' компоненты?",
    "answer": "Контролируемые компоненты — это компоненты, в которых состояние формы управляется React с помощью стейта (например, <input value={state} onChange={handleChange} />). Неконтролируемые компоненты управляют своим состоянием внутри себя, и доступ к данным можно получить через рефы."
  },
  20: {
    "question": "Как создать компонент высшего порядка (HOC)?",
    "answer": "Компонент высшего порядка (HOC) — это функция, которая принимает компонент и возвращает новый компонент с дополнительной логикой или функциональностью. Например: const enhancedComponent = (WrappedComponent) => { return (props) => <WrappedComponent {...props} /> };"
  },
  21: {
    "question": "Что такое state в React?",
    "answer": "State — это объект, который используется для хранения данных или состояния компонента. Состояние может изменяться с течением времени, и React автоматически перерисовывает компонент, когда состояние изменяется."
  },
  22: {
    "question": "Как обновить state в функциональном компоненте?",
    "answer": "В функциональных компонентах для обновления state используется хук useState. Функция, возвращаемая этим хуком, позволяет обновить состояние, например, `setState(newValue)`, где `setState` — это функция обновления состояния."
  },
  23: {
    "question": "Как работает useState?",
    "answer": "useState — это хук в React, который позволяет добавить состояние в функциональные компоненты. Он возвращает пару: текущее значение состояния и функцию для его обновления."
  },
  24: {
    "question": "Почему useState обновляется асинхронно?",
    "answer": "useState обновляется асинхронно, чтобы избежать излишних перерасходов производительности. React группирует обновления состояния и выполняет их позже, после выполнения всех операций в текущем цикле событий, чтобы предотвратить лишние рендеры."
  },
  25: {
    "question": "В чём разница между useState и useReducer?",
    "answer": "useState используется для управления простыми состояниями, а useReducer — для более сложных состояний, которые требуют более сложной логики обновления, таких как несколько взаимозависимых значений. useReducer чаще всего используется для управления состоянием с несколькими действиями (actions)."
  },
  26: {
    "question": "Какие методы жизненного цикла есть в классовых компонентах?",
    "answer": "В классовых компонентах есть несколько методов жизненного цикла, включая: `componentDidMount` (вызывается после монтирования компонента), `componentDidUpdate` (вызывается после обновления компонента), `componentWillUnmount` (вызывается перед размонтированием компонента), а также методы для работы с ошибками, например `componentDidCatch`."
  },
  27: {
    "question": "Чем componentDidMount отличается от componentDidUpdate?",
    "answer": "Метод `componentDidMount` вызывается один раз после первого рендера компонента, в то время как `componentDidUpdate` вызывается каждый раз, когда компонент обновляется после изменения состояния или пропсов."
  },
  28: {
    "question": "Как правильно использовать useEffect?",
    "answer": "useEffect используется для выполнения побочных эффектов в функциональных компонентах. Он выполняется после рендера компонента и может быть настроен для выполнения только при изменении определённых зависимостей (передав их вторым аргументом в массиве)."
  },
  29: {
    "question": "Как предотвратить выполнение useEffect при каждом ререндере?",
    "answer": "Чтобы prevent использовать useEffect при каждом ререндере, нужно передать второй аргумент в виде массива зависимостей. Например, `useEffect(() => { ... }, [dependency])`, где `dependency` — это переменная, которая должна быть отслежена для выполнения эффекта."
  },
  30: {
    "question": "Как выполнить эффект при размонтировании компонента?",
    "answer": "Чтобы выполнить эффект при размонтировании компонента, можно вернуть функцию очистки из useEffect. Эта функция будет вызвана, когда компонент размонтируется, например: `useEffect(() => { return () => { cleanup() }; }, []);`."
  },
  31: {
    "question": "Как работает react-router-dom?",
    "answer": "react-router-dom — это библиотека для управления маршрутизацией в React-приложениях. Она позволяет определять маршруты и компоненты, которые должны отображаться для каждого URL, и поддерживает переходы между страницами без перезагрузки браузера."
  },
  32: {
    "question": "В чём разница между <BrowserRouter> и <HashRouter>?",
    "answer": "<BrowserRouter> использует историю браузера для изменения URL, что позволяет работать с чистыми URL (например, `example.com/about`). <HashRouter> использует хэш-сегмент в URL (например, `example.com/#/about`), что подходит для приложений, которые работают на старых серверах или не поддерживают серверную настройку маршрутов."
  },
  33: {
    "question": "Как передавать параметры в URL через React Router?",
    "answer": "Параметры передаются через URL в React Router с помощью динамических роутов. Например, `path='/user/:id'`, где `:id` — это параметр. Чтобы получить его значение, используется хук `useParams()`."
  },
  34: {
    "question": "Как программно изменить маршрут?",
    "answer": "Для программного изменения маршрута используется хук `useNavigate` из `react-router-dom`. Например, `const navigate = useNavigate(); navigate('/new-route');`."
  },
  35: {
    "question": "Что делает useParams?",
    "answer": "Хук `useParams` позволяет получить доступ к параметрам маршрута в React Router, например, значениям из динамических сегментов пути, таких как `:id`."
  },
  36: {
    "question": "Как защитить роуты в React?",
    "answer": "Для защиты маршрутов в React можно использовать компоненты, такие как `PrivateRoute`, которые проверяют состояние авторизации и, в случае необходимости, перенаправляют пользователя на страницу входа или другую защищённую страницу."
  },
  37: {
    "question": "Что такое 'динамические роуты' в React?",
    "answer": "Динамические роуты в React — это маршруты, которые могут изменяться в зависимости от данных, например, пути с параметрами. Например, `/users/:id` позволяет загружать данные о конкретном пользователе на основе переданного параметра `id`."
  },
  38: {
    "question": "Как задать 'ленивую' загрузку компонентов в роутинге?",
    "answer": "Для ленивой загрузки компонентов в роутинге можно использовать `React.lazy` и `Suspense`. Компонент будет загружен только тогда, когда пользователь перейдёт на соответствующую страницу."
  },
  39: {
    "question": "Как сделать редирект в React?",
    "answer": "Для редиректа в React Router можно использовать компонент `Navigate` или хук `useNavigate` для программного перенаправления."
  },
  40: {
    "question": "Как обновить страницу при изменении маршрута?",
    "answer": "Для обновления страницы при изменении маршрута можно использовать хук `useEffect`, который будет реагировать на изменения маршрута с помощью объекта `location` из `react-router-dom`."
  },
  41: {
    "question": "Как обрабатывать события в React?",
    "answer": "В React обработка событий происходит через синтаксис camelCase, например, `onClick`, `onChange`. События можно обрабатывать, передавая функцию-обработчик как проп, которая будет вызываться при наступлении события."
  },
  42: {
    "question": "В чём разница между onClick={() => func()} и onClick={func}?",
    "answer": "При использовании `onClick={() => func()}` создаётся новая функция при каждом рендере, что может привести к лишним перерендериваниям. `onClick={func}` передаёт ссылку на функцию, что более эффективно и не вызывает лишних рендеров."
  },
  43: {
    "question": "Как передать аргументы в обработчик событий?",
    "answer": "Чтобы передать аргументы в обработчик событий, можно использовать стрелочную функцию, например, `onClick={() => func(arg)}`, или использовать `.bind`, например, `onClick={func.bind(this, arg)}`."
  },
  44: {
    "question": "Почему в обработчиках событий используется event.preventDefault()?",
    "answer": "Метод `event.preventDefault()` используется для предотвращения стандартного поведения события. Например, при отправке формы этот метод может предотвратить перезагрузку страницы."
  },
  45: {
    "question": "Как сделать глобальный обработчик событий в React?",
    "answer": "Для глобальных обработчиков событий можно использовать `useEffect`, чтобы подписаться на события на уровне окна, например, `window.addEventListener('resize', handleResize)`. Не забывайте отписываться от событий при размонтировании компонента."
  },
  46: {
    "question": "Что такое всплытие событий и как его остановить?",
    "answer": "Всплытие событий — это механизм, при котором событие, вызванное на дочернем элементе, передаётся вверх по иерархии DOM-элементов. Для остановки всплытия можно использовать `event.stopPropagation()`, чтобы предотвратить дальнейшее распространение события."
  },
  47: {
    "question": "В чём разница между e.target и e.currentTarget?",
    "answer": "`e.target` ссылается на элемент, на котором произошло событие, а `e.currentTarget` ссылается на элемент, к которому привязан обработчик события (родительский элемент)."
  },
  48: {
    "question": "Почему нельзя напрямую модифицировать event объект в React?",
    "answer": "В React объект события является синтетическим, и его нельзя модифицировать напрямую, так как он может быть переработан и возвращён в пул после выполнения. Для изменения состояния можно использовать другие методы, такие как `useState`."
  },
  49: {
    "question": "Как можно дебаунсить (debounce) события в React?",
    "answer": "Для дебаунса событий в React можно использовать библиотеку `lodash.debounce` или написать собственную реализацию. Обычно дебаунсинг используется для оптимизации часто срабатывающих событий, таких как `onChange` или `scroll`."
  },
  50: {
    "question": "Как сделать кастомный обработчик событий в React?",
    "answer": "Чтобы создать кастомный обработчик событий, нужно определить свою функцию, которая будет вызываться при срабатывании события. Например, можно создать функцию с параметрами для обработки различных событий и логики внутри компонента."
  },
  51: {
    "question": "Чем 'контролируемые' формы отличаются от 'неконтролируемых'?",
    "answer": "'Контролируемая' форма использует React state для управления значениями инпутов, а 'неконтролируемая' форма не использует state, и значения инпутов хранятся в DOM, а управление происходит через refs."
  },
  52: {
    "question": "Как управлять инпутами через useState?",
    "answer": "Для управления инпутами через `useState`, необходимо создать состояние с помощью хука `useState`, а затем передавать это состояние в качестве значения инпута и обновлять его через функцию обновления состояния при изменении инпута."
  },
  53: {
    "question": "Как использовать useRef для работы с инпутами?",
    "answer": "`useRef` позволяет получить доступ к DOM-элементам напрямую. Для работы с инпутами можно использовать `ref` для ссылки на элемент, а затем вызывать методы, такие как `ref.current.value`, для получения или изменения его значения."
  },
  54: {
    "question": "Как обработать отправку формы в React?",
    "answer": "Для обработки отправки формы в React нужно привязать обработчик к событию `onSubmit` формы. В обработчике следует использовать `event.preventDefault()` для предотвращения стандартного поведения и затем выполнить нужные действия, такие как отправка данных на сервер."
  },
  55: {
    "question": "Что такое defaultValue и value у инпутов?",
    "answer": "`defaultValue` используется для задания начального значения инпута в неконтролируемых формах, в то время как `value` управляет значением инпута в контролируемых формах через состояние React."
  },
  56: {
    "question": "Как создать кастомный хук для управления формой?",
    "answer": "Для создания кастомного хука для управления формой, можно использовать `useState` для хранения значений инпутов и функцию для их обновления. Этот хук может возвращать значения и функции для изменения состояния формы."
  },
  57: {
    "question": "Как сделать валидацию формы в React?",
    "answer": "Валидация формы в React может быть выполнена с помощью проверки значений инпутов перед отправкой формы. Можно создать кастомные функции валидации или использовать библиотеки, такие как `Formik` или `React Hook Form`, для упрощения процесса."
  },
  58: {
    "question": "В чём разница между checked и defaultChecked для чекбоксов?",
    "answer": "`defaultChecked` используется для задания начального состояния чекбокса в неконтролируемых компонентах, а `checked` управляет состоянием чекбокса в контролируемых компонентах через состояние React."
  },
  59: {
    "question": "Как работать с select и textarea в React?",
    "answer": "С элементами `select` и `textarea` можно работать, аналогично другим инпутам, используя `value` и `onChange` для управляемых компонентов. В случае с `select` можно использовать `selected` для задания выбранных опций."
  },
  60: {
    "question": "Как можно сохранить состояние формы при изменении страницы?",
    "answer": "Для сохранения состояния формы при изменении страницы можно использовать `localStorage`, `sessionStorage` или библиотеку управления состоянием, такую как `Redux`, для хранения состояния формы."
  },
  61: {
    "question": "Как избежать ненужных ререндеров?",
    "answer": "Чтобы избежать ненужных ререндеров, можно использовать `React.memo` для компонентов, `useMemo` для вычислений, которые не должны перезапускаться при каждом рендере, и `useCallback` для передачи стабильных функций в дочерние компоненты."
  },
  62: {
    "question": "Что делает React.memo?",
    "answer": "`React.memo` — это HOC, который предотвращает ререндер компонента, если его пропсы не изменились. Это полезно для компонентов, которые часто получают одинаковые данные."
  },
  63: {
    "question": "Как работает useCallback?",
    "answer": "`useCallback` мемоизирует функцию и возвращает её только если зависимости изменились. Это позволяет передавать стабильные функции в дочерние компоненты и избежать их пересоздания при каждом рендере."
  },
  64: {
    "question": "Когда использовать useMemo?",
    "answer": "`useMemo` используется для мемоизации значений, которые являются результатами вычислений и не должны перерасчитываться при каждом рендере, если зависимости не изменились."
  },
  65: {
    "question": "Как профилировать производительность компонентов?",
    "answer": "Для профилирования производительности компонентов в React можно использовать встроенные инструменты, такие как `React DevTools`. Также можно использовать `useMemo`, `useCallback` и `React.memo` для оптимизации рендеринга."
  },
  66: {
      "question": "Как работает React.lazy и Suspense?",
      "answer": "`React.lazy` используется для динамической загрузки компонентов по требованию. `Suspense` используется для отображения загрузочного состояния до тех пор, пока компонент не будет загружен."
  },
  67: {
    "question": "В чём разница между key и ref?",
    "answer": "`key` используется для идентификации элементов в списках и оптимизации рендеринга, чтобы React мог эффективно обновлять и перерисовывать компоненты. `ref` используется для получения доступа к DOM-элементам или экземплярам компонентов."
  },
  68: {
    "question": "Почему нельзя использовать индекс массива в key?",
    "answer": "Использование индекса массива в качестве `key` может привести к неправильному поведению при изменении порядка элементов, так как React может неправильно отслеживать элементы, что приведет к ошибкам в состоянии или UI."
  },
  69: {
    "question": "Как правильно использовать React.Fragment?",
    "answer": "`React.Fragment` используется для группировки нескольких элементов, не добавляя лишний DOM-элемент. Это полезно, когда нужно вернуть несколько элементов, но без обертки."
  },
  70: {
    "question": "Как работает ErrorBoundary?",
    "answer": "ErrorBoundary — это компонент, который используется для ловли ошибок JavaScript в компонентах и предотвращения сбоя всего приложения. Он позволяет показать запасной UI при возникновении ошибки в дочернем компоненте."
  },
  71: {
    "question": "Что такое Redux и зачем он нужен?",
    "answer": "Redux — это библиотека для управления состоянием в JavaScript-приложениях. Она помогает централизованно хранить состояние и управлять им, обеспечивая предсказуемость и облегчая отладку."
  },
  72: {
    "question": "Как устроена архитектура Redux?",
    "answer": "Архитектура Redux состоит из трёх основных частей: store (хранит состояние), actions (описывают действия, которые могут быть выполнены), и reducers (обрабатывают действия и обновляют состояние)."
  },
  73: {
    "question": "Что такое action и reducer?",
    "answer": "Action — это объект, который описывает действие, которое необходимо выполнить, и содержит тип действия и дополнительные данные. Reducer — это функция, которая принимает текущее состояние и action, и возвращает новое состояние."
  },
  74: {
    "question": "Как работает useSelector и useDispatch?",
    "answer": "`useSelector` используется для доступа к состоянию в Redux store, а `useDispatch` — для отправки actions, которые изменяют состояние."
  },
  75: {
    "question": "Чем Redux Toolkit отличается от обычного Redux?",
    "answer": "Redux Toolkit предоставляет упрощённый API для работы с Redux, включая встроенные функции для создания actions, reducers и async-логики. Он также помогает уменьшить количество шаблонного кода и улучшить разработку."
  },
  76: {
    "question": "Как работает createSlice?",
    "answer": "`createSlice` из Redux Toolkit упрощает создание actions и reducers для управления состоянием. Он автоматически генерирует необходимые действия и обработчики на основе переданных данных."
  },
  77: {
    "question": "В чём разница между Redux и Context API?",
    "answer": "Redux и Context API оба используются для управления состоянием, но Redux предоставляет более мощные и гибкие инструменты для работы с состоянием в больших приложениях, в то время как Context API удобен для менее сложных задач и локальных состояний."
  },
  78: {
    "question": "Как правильно организовать Redux-хранилище в приложении?",
    "answer": "Для правильной организации Redux-хранилища, важно структурировать его по модулям или функциональности. Каждый модуль может иметь свой slice с действиями и редьюсерами, а все модули могут быть объединены в общий root reducer."
  },
  79: {
    "question": "Как работать с асинхронными запросами в Redux?",
    "answer": "Для работы с асинхронными запросами в Redux обычно используется middleware, такой как `redux-thunk` или `redux-saga`, который позволяет выполнять асинхронные операции внутри action-creator'ов и обновлять состояние по завершении запроса."
  },
  80: {
    "question": "Что делает middleware в Redux?",
    "answer": "Middleware в Redux позволяет перехватывать действия перед тем, как они попадут в reducer. Это может быть полезно для выполнения асинхронных операций, логирования, обработки ошибок и других побочных эффектов."
  },
  81: {
    "question": "В чём разница между React и Next.js?",
    "answer": "React — это библиотека для построения пользовательских интерфейсов, а Next.js — фреймворк, построенный на React, который добавляет дополнительные возможности, такие как серверный рендеринг, статическую генерацию страниц и маршрутизацию."
  },
  82: {
    "question": "Как работает SSR (Server Side Rendering) в Next.js?",
    "answer": "SSR (Server Side Rendering) в Next.js позволяет рендерить страницы на сервере перед отправкой их пользователю, что улучшает SEO и ускоряет начальную загрузку страницы."
  },
  83: {
    "question": "Чем getServerSideProps отличается от getStaticProps?",
    "answer": "getServerSideProps выполняется на сервере при каждом запросе, обеспечивая динамичную загрузку данных, в то время как getStaticProps выполняется при сборке проекта и генерирует страницы с заранее загруженными данными."
  },
  84: {
    "question": "Как создать API-роут в Next.js?",
    "answer": "API-роуты в Next.js создаются в папке `pages/api`, где каждый файл представляет отдельный маршрут API. Например, файл `pages/api/hello.js` будет доступен по пути `/api/hello`."
  },
  85: {
    "question": "Что делает next/link?",
    "answer": "next/link — это компонент, который используется для навигации между страницами в Next.js, обеспечивая предсказуемую маршрутизацию и оптимизацию производительности."
  },
  86: {
    "question": "Как работает next/image и зачем он нужен?",
    "answer": "next/image — это компонент для оптимизированной загрузки изображений в Next.js. Он автоматически адаптирует изображения под размер экрана и генерирует различные форматы изображений, улучшая производительность."
  },
  87: {
    "question": "В чём разница между useRouter и getServerSideProps?",
    "answer": "useRouter используется для получения информации о маршруте на клиенте (например, параметры URL), а getServerSideProps — это серверная функция для загрузки данных до рендеринга страницы."
  },
  88: {
    "question": "Как использовать динамические маршруты в Next.js?",
    "answer": "Для создания динамических маршрутов в Next.js используются квадратные скобки в имени файла, например, `pages/[id].js`, где `id` будет динамическим параметром маршрута."
  },
  89: {
    "question": "Как настроить интернационализацию в Next.js?",
    "answer": "Интернационализацию можно настроить в Next.js с помощью встроенной функции `next-i18next`, которая позволяет создавать многоязычные приложения с переводами и маршрутизацией для разных языков."
  },
  90: {
    "question": "Как деплоить Next.js приложение?",
    "answer": "Next.js приложение можно деплоить на различные платформы, например, Vercel, который предоставляет прямую интеграцию с Next.js, или другие платформы, такие как Netlify или AWS, с соответствующими конфигурациями."
  },
  91: {
    "question": "Как тестировать React-компоненты?",
    "answer": "Для тестирования React-компонентов часто используется библиотека `React Testing Library`, которая позволяет тестировать поведение компонентов и взаимодействие с ними, а также `Jest` для выполнения юнит-тестов."
  },
  92: {
    "question": "В чём разница между shallow и mount в тестировании?",
    "answer": "`shallow` тестирует компонент без его детей, проверяя только сам компонент, а `mount` рендерит компонент и его детей, позволяя тестировать их взаимодействие."
  },
  93: {
    "question": "Что такое порталы (React Portals) и зачем они нужны?",
    "answer": "Порталы позволяют рендерить дочерние элементы компонента в другом месте в DOM-дереве, что полезно, например, для модальных окон, всплывающих подсказок и других элементов, которые требуют рендеринга вне иерархии родительских компонентов."
  },
  94: {
    "question": "Как передавать данные между компонентами без props и redux?",
    "answer": "Для передачи данных между компонентами без использования `props` или `redux` можно использовать `context API` или `useContext` для глобального состояния, а также `useRef` для ссылок на DOM-элементы."
  },
  95: {
    "question": "Как работать с context API?",
    "answer": "Context API используется для создания глобального состояния, которое можно передавать между компонентами, минуя промежуточные уровни. С помощью `createContext` создаётся контекст, а с помощью `useContext` можно получить данные из контекста."
  },
  96: {
    "question": "Можно ли использовать hooks в классовых компонентах?",
    "answer": "Нет, хуки можно использовать только в функциональных компонентах. Классовые компоненты не поддерживают хуки."
  },
  97: {
    "question": "Почему useEffect может выполняться дважды?",
    "answer": "Выполнение `useEffect` дважды может происходить в режиме разработки из-за включённого строгого режима (Strict Mode) в React, что помогает выявлять побочные эффекты, не влияя на продуктивный режим."
  },
  98: {
    "question": "Как отловить ошибки в React-компонентах?",
    "answer": "Для ловли ошибок в React можно использовать компонент `ErrorBoundary`, который ловит ошибки в дочерних компонентах и позволяет отобразить запасной UI."
  },
  99: {
    "question": "Как сделать бесконечный скролл (infinite scroll) в React?",
    "answer": "Для реализации бесконечного скролла можно использовать событие `scroll`, чтобы отслеживать положение страницы и подгружать данные, когда пользователь прокручивает страницу до конца. Также можно использовать сторонние библиотеки, такие как `react-infinite-scroll-component`."
  },
  100: {
    "question": "Что делать, если большой список элементов замедляет рендеринг?",
    "answer": "Чтобы улучшить производительность, можно использовать виртуализацию списка с помощью библиотеки, такой как `react-virtualized` или `react-window`, которые рендерят только видимые элементы."
  },
  "total": 100
}