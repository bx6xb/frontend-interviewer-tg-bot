css_questions = {
  1: {
    "question": "Что такое CSS и для чего он используется?",
    "answer": "CSS (Cascading Style Sheets) используется для стилизации веб-страниц. Он позволяет отделить структуру документа (HTML) от визуального представления."
  },
  2: {
    "question": "Какие способы подключения CSS к HTML существуют?",
    "answer": "CSS можно подключить тремя способами: через внешний файл с помощью тега <link>, встроенные стили с использованием тега <style> и inline стили прямо в атрибуте элемента."
  },
  3: {
    "question": "В чём разница между em, rem, %, vh, vw и px?",
    "answer": "em и rem - это относительные единицы измерения, зависящие от размера шрифта. % - тоже относительная единица, но зависящая от родительского элемента. vh и vw - это относительные единицы, основанные на размере окна браузера. px - абсолютная единица, не зависящая от других параметров."
  },
  4: {
    "question": "Как работает каскадность (Cascade) в CSS?",
    "answer": "Каскадность определяет, какой стиль применяется, если несколько правил совпадают для одного элемента. Приоритет определяется спецификой селектора и порядком следования стилей."
  },
  5: {
    "question": "Что такое специфичность (Specificity) и как она рассчитывается?",
    "answer": "Специфичность — это система приоритетов, по которой браузер решает, какой стиль применить. Она рассчитывается на основе количества типов селекторов: ID, классов и элементов."
  },
  6: {
    "question": "Как работает наследование (Inheritance) в CSS?",
    "answer": "Наследование позволяет элементам наследовать стили от их родительских элементов. Например, текстовые стили, такие как цвет шрифта, обычно наследуются от родителя."
  },
  7: {
    "question": "В чём разница между relative, absolute, fixed и sticky позиционированием?",
    "answer": "relative позиционирование сдвигает элемент относительно его нормального положения. absolute позиционирование основывается на ближайшем позиционированном родителе. fixed фиксирует элемент относительно окна браузера. sticky позиционирование сочетает поведение relative и fixed, фиксируя элемент при прокрутке."
  },
  8: {
    "question": "Как работает z-index и какие у него особенности?",
    "answer": "z-index управляет порядком наложения элементов. Элементы с более высоким значением z-index будут отображаться поверх тех, у которых это значение меньше. Он работает только для элементов с позиционированием."
  },
  9: {
    "question": "Как сделать так, чтобы элемент занимал всю высоту экрана?",
    "answer": "Чтобы элемент занимал всю высоту экрана, можно использовать высоту в 100vh (view height), например, height: 100vh."
  },
  10: {
    "question": "Чем visibility: hidden отличается от display: none?",
    "answer": "visibility: hidden скрывает элемент, но он продолжает занимать место в макете, тогда как display: none полностью удаляет элемент из макета."
  },
  11: {
    "question": "Какие основные селекторы есть в CSS?",
    "answer": "Основные селекторы в CSS включают селекторы по тегу, классу, ID, атрибуту, псевдоклассы и псевдоэлементы."
  },
  12: {
    "question": "Как работает селектор потомков (div p) и дочерний селектор (div > p)?",
    "answer": "Селектор потомков (div p) выбирает все элементы <p>, которые находятся внутри <div>. Дочерний селектор (div > p) выбирает только те элементы <p>, которые являются прямыми детьми <div>."
  },
  13: {
    "question": "Как работает селектор соседних элементов (+ и ~)?",
    "answer": "Селектор соседних элементов (div + p) выбирает элемент <p>, который непосредственно следует за <div>. Селектор (~) выбирает все элементы <p>, которые следуют за <div>, независимо от промежуточных элементов."
  },
  14: {
    "question": "Как выбрать элемент с определённым атрибутом ([attr='value'])?",
    "answer": "Для выбора элемента с определённым атрибутом используется синтаксис [attr='value'], где 'attr' - имя атрибута, а 'value' - его значение."
  },
  15: {
    "question": "Что такое ::before и ::after, и как они используются?",
    "answer": "::before и ::after - это псевдоэлементы, которые позволяют вставлять контент перед или после содержимого элемента. Они часто используются для добавления декоративных элементов."
  },
  16: {
    "question": "Как сделать анимацию появления элемента без JavaScript?",
    "answer": "Для анимации появления элемента можно использовать CSS анимации с @keyframes, изменяя свойства, такие как opacity и transform."
  },
  17: {
    "question": "Чем nth-child() отличается от nth-of-type()?",
    "answer": "nth-child() выбирает элементы, основываясь на их позиции среди всех братьев и сестёр, независимо от типа. nth-of-type() выбирает элементы, основываясь на их позиции среди однотипных элементов."
  },
  18: {
    "question": "Как сделать текст многострочным и обрезать его с ...?",
    "answer": "Для многострочного текста с обрезанием можно использовать свойство CSS overflow: hidden; и text-overflow: ellipsis;."
  },
  19: {
    "question": "Как центрировать элемент по горизонтали и вертикали?",
    "answer": "Для центрирования элемента по горизонтали и вертикали можно использовать flexbox или grid, с align-items: center и justify-content: center."
  },
  20: {
    "question": "В чём разница между currentColor и inherit?",
    "answer": "currentColor - это ключевое слово, которое использует текущее значение цвета элемента, а inherit - позволяет элементу наследовать значение свойства от родительского элемента."
  },
  21: {
    "question": "Какие основные свойства есть у Flexbox?",
    "answer": "Основные свойства Flexbox включают: display: flex, flex-direction, justify-content, align-items, align-self, flex-wrap, flex-grow, flex-shrink и flex-basis."
  },
  22: {
    "question": "Чем justify-content отличается от align-items?",
    "answer": "justify-content управляет распределением элементов вдоль главной оси, а align-items - вдоль поперечной оси контейнера."
  },
  23: {
    "question": "Как сделать равномерное распределение элементов с flex?",
    "answer": "Для равномерного распределения элементов можно использовать свойство justify-content со значением space-between или space-around."
  },
  24: {
    "question": "Как работает свойство flex-grow?",
    "answer": "flex-grow определяет, насколько элемент может расширяться относительно других элементов внутри контейнера. Чем больше значение, тем больше элемент будет расти."
  },
  25: {
    "question": "В чём разница между flex-wrap: wrap и flex-wrap: nowrap?",
    "answer": "flex-wrap: wrap позволяет элементам переноситься на следующую строку, если не хватает места, а flex-wrap: nowrap запрещает перенос элементов."
  },
  26: {
    "question": "Чем CSS Grid отличается от Flexbox?",
    "answer": "CSS Grid позволяет создавать сетки с строками и колонками, а Flexbox работает с элементами вдоль одной оси (горизонтальной или вертикальной)."
  },
  27: {
    "question": "Как сделать три колонки равной ширины с Grid?",
    "answer": "Для создания трех колонок равной ширины можно использовать grid-template-columns: repeat(3, 1fr);"
  },
  28: {
    "question": "Как работает grid-template-areas?",
    "answer": "grid-template-areas позволяет задать имена для областей в сетке, а затем с помощью grid-area можно располагать элементы в этих областях."
  },
  29: {
    "question": "В чём разница между minmax() и auto-fit/auto-fill в Grid?",
    "answer": "minmax() позволяет задать минимальную и максимальную ширину или высоту для ячеек, auto-fit/auto-fill используются для автоматического заполнения пространства колонками или строками, с учётом минимальных размеров."
  },
  30: {
    "question": "Как выровнять элемент в Grid, если ячейка больше контента?",
    "answer": "Для выравнивания контента внутри ячейки можно использовать свойства justify-items и align-items с значениями, такими как center или start."
  },
  31: {
    "question": "Как работает transition и какие у него параметры?",
    "answer": "transition позволяет анимировать изменение свойств элемента. Он имеет параметры: property (свойство), duration (время), timing-function (функция времени) и delay (задержка)."
  },
  32: {
    "question": "Чем animation отличается от transition?",
    "answer": "animation позволяет создавать более сложные анимации с ключевыми кадрами и повторениями, а transition ограничивается анимацией изменений свойств с одного состояния в другое."
  },
  33: {
    "question": "Как сделать бесконечную анимацию?",
    "answer": "Для бесконечной анимации можно использовать свойство animation со значением infinite в параметре animation-iteration-count."
  },
  34: {
    "question": "Что такое cubic-bezier и как он влияет на анимацию?",
    "answer": "cubic-bezier - это функция временной кривой, которая позволяет создавать пользовательские эффекты скорости анимации, заменяя стандартные easing-функции."
  },
  35: {
    "question": "В чём разница между transform: translate() и position: absolute?",
    "answer": "transform: translate() изменяет положение элемента относительно его текущего положения без влияния на поток документа, а position: absolute позволяет элементу быть выведенным из потока и позиционированным относительно ближайшего позиционированного родителя."
  },
  36: {
    "question": "Как сделать сайт адаптивным?",
    "answer": "Для адаптивного сайта нужно использовать медиазапросы, относительные единицы измерения и флексбокс или CSS Grid для адаптивной верстки."
  },
  37: {
    "question": "Какие бывают media-запросы и как их использовать?",
    "answer": "Медиазапросы могут быть использованы для изменения стилей в зависимости от ширины экрана, ориентации устройства, разрешения и других характеристик. Пример: @media (max-width: 768px) { ... }."
  },
  38: {
    "question": "В чём разница между max-width и min-width в медиа-запросах?",
    "answer": "max-width применяется, когда экран меньше указанной ширины, а min-width - когда экран больше указанной ширины."
  },
  39: {
    "question": "Что такое mobile-first и desktop-first подход?",
    "answer": "Mobile-first предполагает создание дизайна для мобильных устройств с минимальными размерами экрана, а затем использование медиазапросов для большего разрешения. Desktop-first - наоборот, дизайн создается для больших экранов, и затем адаптируется для мобильных."
  },
  40: {
    "question": "Как изменить порядок элементов в flex-контейнере на мобильных устройствах?",
    "answer": "Для изменения порядка элементов на мобильных устройствах можно использовать свойство order в сочетании с медиазапросами."
  },
  41: {
    "question": "Как работают CSS-переменные (var(--color))?",
    "answer": "CSS-переменные позволяют создавать значения, которые можно переиспользовать в разных частях стилей. Они объявляются с помощью синтаксиса '--имя-переменной: значение;' и могут быть использованы с функцией 'var(--имя-переменной)' в любой части CSS. Переменные могут зависеть от родительского элемента или контекста, если они объявлены внутри :root или другого блока."
  },
  42: {
    "question": "Можно ли изменить CSS-переменную в JavaScript? Как?",
    "answer": "Да, CSS-переменные можно изменять с помощью JavaScript. Для этого используется метод 'setProperty' объекта 'style' элемента. Пример: document.documentElement.style.setProperty('--color', 'red'); Это изменит значение переменной '--color' на 'red' для всего документа."
  },
  43: {
    "question": "Чем SCSS отличается от обычного CSS?",
    "answer": "SCSS — это расширение CSS, которое добавляет дополнительные возможности, такие как переменные, вложенность, миксины, функции и другие фичи, позволяя писать более организованный и удобочитаемый код. В отличие от обычного CSS, SCSS компилируется в стандартный CSS и поддерживает более сложную структуру и динамическое поведение."
  },
  44: {
    "question": "Что такое mixin в SCSS и зачем он нужен?",
    "answer": "Mixin в SCSS — это блок кода, который можно переиспользовать в разных местах. Это позволяет избежать дублирования кода, улучшая поддержку и читаемость стилей. Миксины могут принимать параметры и инжектировать код в другие стили, облегчая управление стилями, например, для создания универсальных функций и компонентов."
  },
  45: {
    "question": "Какие преимущества дает вложенность (& в SCSS)?",
    "answer": "Вложенность с использованием '&' в SCSS позволяет организовать стили, сокращая повторяющийся код и улучшая структуру. Например, использование '&' позволяет ссылаться на родительский элемент в контексте вложенного правила, что упрощает создание более читаемых и организованных стилей, особенно при работе с компонентами и состояниями."
  },
  46: {
    "question": "Какие свойства CSS самые ресурсоёмкие?",
    "answer": "Самыми ресурсоёмкими свойствами в CSS являются 'box-shadow', 'filter', 'transform' (особенно при анимации), 'position' (особенно 'absolute' и 'fixed') и 'width/height' при динамическом изменении. Эти свойства могут вызвать пересчёт и перерисовку элементов, что нагружает процессор."
  },
  47: {
    "question": "Как уменьшить количество перерисовок (repaint) и пересчётов (reflow) в браузере?",
    "answer": "Для уменьшения перерисовок и пересчётов следует минимизировать манипуляции с DOM, использовать классические методы CSS для анимаций (например, 'transform' и 'opacity'), избегать часто изменяющихся свойств, использовать 'will-change' с осторожностью и избегать изменений размеров и расположения элементов на странице во время анимаций."
  },
  48: {
    "question": "Почему will-change может ускорить анимацию, но опасен?",
    "answer": "Свойство 'will-change' говорит браузеру заранее, какие элементы будут изменяться, позволяя оптимизировать рендеринг. Однако, если его использовать слишком часто или на большом количестве элементов, это может привести к излишней нагрузке на процессор и ухудшению производительности, так как браузер будет выделять дополнительные ресурсы для этих изменений."
  },
  49: {
    "question": "Чем contain может помочь в оптимизации?",
    "answer": "CSS свойство 'contain' помогает ограничить область влияния элемента на рендеринг, исключая излишние вычисления для элементов, которые не должны влиять на остальные части страницы. Это может значительно улучшить производительность при работе с большими или сложными страницами, ограничивая, например, области, которые должны быть пересчитаны или перерисованы."
  },
  50: {
    "question": "Как минимизировать влияние внешних шрифтов на скорость загрузки страницы?",
    "answer": "Чтобы минимизировать влияние внешних шрифтов на скорость загрузки, можно использовать следующие методы: 1) подгрузка шрифтов асинхронно с использованием 'font-display: swap'; 2) ограничение количества используемых шрифтов и стилей; 3) применение встроенных шрифтов через base64-кодирование для сокращения количества HTTP-запросов; 4) оптимизация форматов шрифтов (например, использование WOFF2)."
  },
  "total": 50
}
